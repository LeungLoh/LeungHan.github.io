<!DOCTYPE html><html data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>（四）Linux进程通信 | 特立独型</title><meta name="description" content="（四）Linux进程通信"><meta name="keywords" content="Linux应用编程"><meta name="author" content="特立独型"><meta name="copyright" content="特立独型"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="（四）Linux进程通信"><meta name="twitter:description" content="（四）Linux进程通信"><meta name="twitter:image" content="leunghan.github.io/img/Linux应用编程/cover.jpg"><meta property="og:type" content="article"><meta property="og:title" content="（四）Linux进程通信"><meta property="og:url" content="leunghan.github.io/2017/11/12/%EF%BC%88%E5%9B%9B%EF%BC%89Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"><meta property="og:site_name" content="特立独型"><meta property="og:description" content="（四）Linux进程通信"><meta property="og:image" content="leunghan.github.io/img/Linux应用编程/cover.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="leunghan.github.io/2017/11/12/%EF%BC%88%E5%9B%9B%EF%BC%89Linux%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"><link rel="prev" title="记2018暑期夏令营——东华大学&amp;重庆大学" href="/leunghan.github.io/2018/07/16/%E8%AE%B02018%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E2%80%94%E2%80%94%E4%B8%9C%E5%8D%8E%E5%A4%A7%E5%AD%A6&amp;%E9%87%8D%E5%BA%86%E5%A4%A7%E5%AD%A6/"><link rel="next" title="（三）Linux进程控制" href="/leunghan.github.io/2017/10/31/%EF%BC%88%E4%B8%89%EF%BC%89Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.1.1"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">特立独型</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">9</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">3</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">2</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#Linux进程通信"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Linux进程通信</span></a></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux进程通信"><span class="toc-number">1.</span> <span class="toc-text">Linux进程通信</span></a></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/Linux应用编程/cover.jpg)"><div id="post-info"><div id="post-title"><div class="posttitle">（四）Linux进程通信</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2017-11-12<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2019-12-20</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/Linux/">Linux</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>Linux中几种通信方式：管道、信号、消息队列、共享内存、信号量的原理、实现代码和运行结果</p>
<a id="more"></a>

<h2 id="Linux进程通信"><a href="#Linux进程通信" class="headerlink" title="Linux进程通信"></a><strong>Linux进程通信</strong></h2><p><strong>进程间通信概述：</strong></p>
<p>1、数据传输<br>一个进程需要将他的数据发送给另一个进程。</p>
<p>2、资源共享<br>多个进程之间共享同样的资源。</p>
<p>3、通知事件<br>一个进程需要向另一个或一组进程发送消息，通知他们发生了某种时间。</p>
<p>4、进程控制<br>有些进程希望完全控制另一个进程的执行（如Debug进程），此时控制进程希望能够拦截另一个进程的所有操作，bin能够及时知道他的状态改变 。</p>
<p><strong>进程间通信方式：</strong><br>1、管道（pipe）和有名管道（FIFO）<br>2、信号（signal）<br>3、消息队列<br>4、共享内存<br>5、信号量<br>6、套接字（socket）</p>
<hr>
<p><strong>一、管道通信：</strong></p>
<p>管道通信是单向的、先进先出的，把一个进程的输出和另一个进程的输入连接在一起。一个进程（写进程）在管道的尾部写入数据，另一个进程（读进程）从管道的头部读出数据 </p>
<p>管道包括无名管道和有名管道两种，前者用于父进程和子进程间的通信，后者课用于运行于同一系统中任意两个子进程间的通信</p>
<p><strong>无名管道pipe()：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pipe(int filedis[2]);</span><br></pre></td></tr></table></figure></div>

<p>当一个管道建立时，他会创建两个文件描述符filedis[0]用于读管道，filedis[2]用于写管道必须在fork之前调用pipe，否则子进程将不会继承文件描述符</p>
<p><strong>pipe_rw.c</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt; </span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	int pipe_fd[2];</span><br><span class="line">	pid_t pid;</span><br><span class="line">	char buf_r[100];</span><br><span class="line">	char *p_wbuf;</span><br><span class="line">	int r_num;</span><br><span class="line">	</span><br><span class="line">	memset(buf_r,0,sizeof(buf_r));</span><br><span class="line">	</span><br><span class="line">	&#x2F;*创建管道*&#x2F;</span><br><span class="line">	if(pipe(pipe_fd)&lt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;pipe creat error\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;*创建子进程*&#x2F;</span><br><span class="line">	if((pid&#x3D;fork())&#x3D;&#x3D;0)			&#x2F;&#x2F;在子进程中</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;\n&quot;);</span><br><span class="line">		close(pipe_fd[1]);		&#x2F;&#x2F;关闭写数据</span><br><span class="line">		</span><br><span class="line">		sleep(2);				&#x2F;&#x2F;让子进程停下来，父进程运行向管道中写数据</span><br><span class="line">		</span><br><span class="line">		if((r_num&#x3D;read(pipe_fd[0],buf_r,100))&gt;0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;%d numbers read from the pipe is %s\n&quot;,r_num,buf_r);</span><br><span class="line">		&#125;</span><br><span class="line">		close(pipe_fd[0]);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	else if(pid&gt;0)</span><br><span class="line">	&#123;</span><br><span class="line">		close(pipe_fd[0]);		&#x2F;&#x2F;关闭读数据</span><br><span class="line">					</span><br><span class="line">		if(write(pipe_fd[1],&quot;Hello&quot;,5)!&#x3D;-1)</span><br><span class="line">			printf(&quot;parent writel Hello!\n&quot;);</span><br><span class="line">				</span><br><span class="line">		if(write(pipe_fd[1],&quot; Pipe&quot;,5)!&#x3D;-1) </span><br><span class="line">			printf(&quot;parent write2 Pipe!\n&quot;);</span><br><span class="line">			</span><br><span class="line">		close(pipe_fd[1]);		&#x2F;&#x2F;数据写入完毕</span><br><span class="line">			</span><br><span class="line">		sleep(3);				&#x2F;&#x2F;让父进程停下来，子进程运行从管道中读数据</span><br><span class="line">		</span><br><span class="line">		waitpid(pid,NULL,0);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：<br><a href="http://img.blog.csdn.net/20171112191158197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGlhbmdfUXVhbl9IdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="http://img.blog.csdn.net/20171112191158197?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGlhbmdfUXVhbl9IdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" title></a></p>
<p><strong>命名管道FIFO：</strong><br>命名管道和无名管道基本相同，但也有不同点：<br>无名管道只能有父子进程使用；<br>但是通过命名管道，不相关的进程也能交换数据</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include&lt;sys&#x2F;stat.h&gt;</span><br><span class="line">int mkfifo(const char * pathname,mode_t mode)</span><br></pre></td></tr></table></figure></div>
<p>pathname :FIFO文件名<br>mode： 属性</p>
<p>一旦创建了一个FIFO，就可以用open打开他，一般的文件访问函数（close，read，write等）都可以用于FIFO</p>
<p>打开FIFO时，非阻塞标志（O_NONBLOCK）<br>1、没使用O_NONBLOCK：访问要求无法满足时进程将阻塞，如试图读取空的FIFO，将导致进程阻塞<br>2、使用O_NONBLOCK:访问要求无法满足时不阻塞，立刻出错返回，errno是ENXIO</p>
<p><strong>fifo_read.c</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define FIFO &quot;&#x2F;tmp&#x2F;myfifo&quot;</span><br><span class="line"> </span><br><span class="line">void main(int argc,char** argv)</span><br><span class="line">&#123;</span><br><span class="line">	char buf_r[100];</span><br><span class="line">	int fd;</span><br><span class="line">	int nread;</span><br><span class="line">	</span><br><span class="line">	if(mkfifo(FIFO,O_CREAT|O_EXCL)&lt;0)</span><br><span class="line">		printf(&quot;cannot creat fifosever\n&quot;);</span><br><span class="line">	</span><br><span class="line">	printf(&quot;Preparing for reading bytes...\n&quot;);</span><br><span class="line">	</span><br><span class="line">	memset(buf_r,0,sizeof(buf_r));</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;打开管道，只读且不阻塞</span><br><span class="line">	fd&#x3D;open(FIFO,O_RDONLY|O_NONBLOCK,0);</span><br><span class="line">	</span><br><span class="line">	if(fd &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;open&quot;);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		memset(buf_r,0,sizeof(buf_r));</span><br><span class="line">		</span><br><span class="line">		if((nread&#x3D;read(fd,buf_r,100))&#x3D;&#x3D;-1)</span><br><span class="line">		&#123;</span><br><span class="line">			if(errno &#x3D;&#x3D; EAGAIN)</span><br><span class="line">				printf(&quot;no data yet\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		printf(&quot;read %s from FIFO\n&quot;,buf_r);</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	pause();&#x2F;&#x2F;暂停，等待信号 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>fifo_write.c</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line"></span><br><span class="line">#define FIFO_SERVER &quot;&#x2F;tmp&#x2F;myfifo&quot;</span><br><span class="line"></span><br><span class="line">void main(int argc,char** argv)</span><br><span class="line">&#123;</span><br><span class="line">	int fd;</span><br><span class="line">	char w_buf[100];</span><br><span class="line">	int nwrite;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;打开管道，只写且不阻塞</span><br><span class="line">	fd&#x3D;open(FIFO_SERVER,O_WRONLY|O_NONBLOCK,0);</span><br><span class="line">	</span><br><span class="line">	if(argc &#x3D;&#x3D; 1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;Please send something\n&quot;);</span><br><span class="line">		exit(-1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	strcpy(w_buf,argv[1]);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;向管道写入数据</span><br><span class="line">	if( (nwrite&#x3D;write(fd,w_buf,100)) &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		if(errno&#x3D;&#x3D;EAGAIN)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;The FIFO has not been read yet.Please try later\n&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	else</span><br><span class="line">		printf(&quot;write %s to the FIFO\n&quot;,w_buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：<br><a href="http://img.blog.csdn.net/20171112191221643?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGlhbmdfUXVhbl9IdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="http://img.blog.csdn.net/20171112191221643?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGlhbmdfUXVhbl9IdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" title></a></p>
<p><strong>二、信号通信：</strong></p>
<p><strong>kill、raise</strong><br>发送信号函数kill和raise：<br>kill既可以想自身发送信号，也可以向其他进程发送信号<br>raise是向进程自身发送信号</p>
<p>kill -s 信号 pid</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">int kill(pid_t pid,int signo)</span><br><span class="line">int raise(int signo)</span><br></pre></td></tr></table></figure></div>

<p><strong>alarm</strong><br>alarm可以设置一个时间值（闹钟时间），当所设置的时间到了时，产生SIGAKRM信号。如果不捕获此信号，则默认动作是终止该进程。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">unsigned int alarm(unsigned int seconds)</span><br></pre></td></tr></table></figure></div>
<p>seconds:经过了指定的seconds秒后会产生信号SIGALRM</p>
<p><strong>pause</strong><br>pause函数使用调用进程挂起直至捕捉到一个信号</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">int pause (void)</span><br></pre></td></tr></table></figure></div>

<p><strong>signal</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">void (*signal(int signo,void (*func)(int)))(int)</span><br></pre></td></tr></table></figure></div>
<p>若成功，返回以前的信号处理配置<br>若出错，返回SIG_ERR</p>
<p>将函数拆分：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*sighandler_t)(int)</span><br><span class="line">sighandler_t signal(int signum,sighandler_t handler)</span><br></pre></td></tr></table></figure></div>
<p>使用ps aux命令可以查看进程</p>
<p><strong>mysignal.c</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;signal.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void my_func(int sign_no)</span><br><span class="line">&#123;</span><br><span class="line">	if(sign_no &#x3D;&#x3D; SIGINT)</span><br><span class="line">		printf(&quot;I have get SIGINT\n&quot;);</span><br><span class="line">	</span><br><span class="line">	else if(sign_no&#x3D;&#x3D;SIGQUIT)</span><br><span class="line">		printf(&quot;I have get SIGQUIT\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;Waiting foe signal SIGINT or SIGQUIT \n &quot;);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;注册信号处理函数</span><br><span class="line">	signal(SIGINT,my_func);</span><br><span class="line">	signal(SIGQUIT,my_func);</span><br><span class="line">	</span><br><span class="line">	pause();</span><br><span class="line">	</span><br><span class="line">	exit(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：<br><a href="http://img.blog.csdn.net/20171112193332064?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGlhbmdfUXVhbl9IdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="http://img.blog.csdn.net/20171112193332064?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGlhbmdfUXVhbl9IdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" title></a></p>
<p><strong>三、共享内存：</strong><br>是被多个进程共享的一部分的物理内存。共享内存是进程间共享数据的一种最快的方法，一个进程向共享内存写入了数据，共享这个内存区域的所有进程就可以立刻看到其中的内容。</p>
<p>共享内存实现方法：<br>一、创建共享内存，使用shmget函数<br>二、映射共享内存，将这段创建的共享内存映射到具体的进程空间去，使用shmat函数</p>
<p><strong>创建：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;shm.h&gt;</span><br><span class="line">int shmget(key_t key,int size,int shmflg)</span><br></pre></td></tr></table></figure></div>
<p>返回值：如果成功，返回共享内存标识符；如果失败，返回-1</p>
<p><strong>映射：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;shm.h&gt;</span><br><span class="line">int shmat(int shmid,char *shmaddr,int flag)</span><br></pre></td></tr></table></figure></div>
<p>shmid:shmget函数返回的共享内存存储标识符<br>flag：觉得以什么方式来确定映射的地址（通常为0）</p>
<p>返回值：如果成功，则返回共享内存映射到进程中的地址；如果失败，则返回-1</p>
<p>*<em>解除： *</em></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;shm.h&gt;</span><br><span class="line">int shmdt(char *shmaddr)</span><br></pre></td></tr></table></figure></div>
<p>返回值：成功返回0，出错返回-1</p>
<p><strong>shmem.c</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;stat.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;shm.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;wait.h&gt;</span><br><span class="line">#include &lt;errno.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">#define PERM S_IRUSR|S_IWUSR</span><br><span class="line">&#x2F;*共享内存*&#x2F;</span><br><span class="line">int main(int argc,char **argv)</span><br><span class="line">&#123;</span><br><span class="line">	int shmid;</span><br><span class="line">	char *p_addr,*c_addr;</span><br><span class="line">	</span><br><span class="line">	if(argc!&#x3D;2)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr,&quot;Usage:%s\n\a&quot;,argv[0]);</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;创建共享内存</span><br><span class="line">	if((shmid&#x3D;shmget(IPC_PRIVATE,1024,PERM))&#x3D;&#x3D;-1)</span><br><span class="line">	&#123;</span><br><span class="line">		fprintf(stderr,&quot;Create Share Memory ERROR:%s\n\a&quot;,strerror(errno));</span><br><span class="line">		exit(1);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;创建子进程</span><br><span class="line">	if(fork())</span><br><span class="line">	&#123;</span><br><span class="line">		p_addr&#x3D;shmat(shmid,0,0);&#x2F;&#x2F;穿0表示有系统自动寻找一个地址</span><br><span class="line">		memset(p_addr,&#39;\0&#39;,1024);&#x2F;&#x2F;对某一块内存区“清楚”，本历程全部格式化为‘\0’</span><br><span class="line">		strncpy(p_addr,argv[1],1024);</span><br><span class="line">		wait(NULL);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	else</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(1);&#x2F;&#x2F;防止子进程先运行 </span><br><span class="line">		c_addr&#x3D;shmat(shmid,0,0);</span><br><span class="line">		printf(&quot;Client get %s\n&quot;,c_addr);</span><br><span class="line">		exit(0);</span><br><span class="line">	&#125;		</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：<br><a href="http://img.blog.csdn.net/20171112195253071?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGlhbmdfUXVhbl9IdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="http://img.blog.csdn.net/20171112195253071?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGlhbmdfUXVhbl9IdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" title></a></p>
<p><strong>四、消息队列：</strong></p>
<p>POSIX消息队列、系统V消息队列<br>POSIX：可移植操作系统接口</p>
<p>系统V消息队列是随内核持续的，只有在内核重启或者人工删除时，该消息队列才会被删除 。</p>
<p>消息队列就是一个消息的链表，可以吧消息看做一个记录，有特定的格式，进程可以向其中按一定规则添加新的消息，另一些进程可以从消息队列中读出消息。</p>
<p>消息队列的内核持续性要求每个消息队列都在系统范围内对应唯一的键值，所以，要获得一个消息队列的描述字，必须提供该消息队列的键值 。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line"></span><br><span class="line">key_t ftok(char *pathname,char proj)</span><br></pre></td></tr></table></figure></div>
<p>功能：返回文件名对应的键值<br>pathname：文件名<br>proj：项目名（不为0即可）</p>
<p><strong>打开/创建</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">	int msgget(key_t key,int msgflg)</span><br></pre></td></tr></table></figure></div>

<p>key:键值，由ftok获得<br>msgflg：标志位<br>返回值：与键值key相对应的消息队列描述字</p>
<p>标志位：<br>IPC_CREAT:创建新的消息队列<br>IPC_EXCL：与IPC_CREAT一同使用，表示如果要创建的消息队列已经存在，则返回错误<br>IPC_NOWAIT：读写消息队列要求无法的到满足时，不阻塞</p>
<p>在以下两种情况下，将创建一个新的消息队列：<br>1、如果没有与键值key相对应的消息队列，并且msgflg中包含了IPC_CREAT标志位。<br>2、key参数为IPC_PRIVATE</p>
<p><strong>发送消息：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">int msgsnd(int msqid,struct msgbuf* msgp,int msgsz,int msgflg)</span><br></pre></td></tr></table></figure></div>
<p>功能：向消息队列发送一条消息</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct msgbuf</span><br><span class="line">&#123;</span><br><span class="line">	long mtype;	  &#x2F;&#x2F;消息类型&gt;0</span><br><span class="line">	char mtext[1];&#x2F;&#x2F;消息数据的首地址</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>接收消息：</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">int msgrcv(int msqid,struct msgbuf* msgp,int msgsz,long msgtyp,int msgflg)</span><br></pre></td></tr></table></figure></div>
<p>功能：从msqid代表的消息队列中读取一个msgtyp类型的消息，并吧消息存储在msgp指向msgbuf结构中。在成功读取一条消息后，队列中的这条消息将被删除。</p>
<p><strong>msg.c</strong></p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">struct msg_buf</span><br><span class="line">&#123;</span><br><span class="line">	long mtype;	  &#x2F;&#x2F;消息类型&gt;0</span><br><span class="line">	char data[255];&#x2F;&#x2F;消息数据的首地址</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	key_t key;</span><br><span class="line">	int msgid;</span><br><span class="line">	int ret;</span><br><span class="line">	struct msg_buf msgbuf;</span><br><span class="line">	</span><br><span class="line">	&#x2F;*</span><br><span class="line">	key_t ftok(char *pathname,char proj)</span><br><span class="line">	功能：返回文件名对应的键值</span><br><span class="line">	pathname：文件名</span><br><span class="line">	proj：项目名（不为0即可）</span><br><span class="line">	消息队列也是一个文件</span><br><span class="line">	*&#x2F;</span><br><span class="line">	</span><br><span class="line">	key&#x3D;ftok(&quot;&#x2F;tmp&#x2F;2&quot;,&#39;a&#39;);</span><br><span class="line">	printf(&quot;key&#x3D;[%x]\n&quot;,key);</span><br><span class="line">	</span><br><span class="line">	&#x2F;*</span><br><span class="line">	打开&#x2F;创建</span><br><span class="line">	#include &lt;sys&#x2F;types.h&gt;</span><br><span class="line">	#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">	#include &lt;sys&#x2F;msg.h&gt;</span><br><span class="line">	int msgget(key_t key,int msgflg)</span><br><span class="line">	</span><br><span class="line">	key:键值，由ftok获得</span><br><span class="line">	msgflg：标志位</span><br><span class="line">	返回值：与键值key相对应的消息队列描述字</span><br><span class="line">	*&#x2F;</span><br><span class="line">	msgid&#x3D;msgget(key,IPC_CREAT|0666);</span><br><span class="line">	</span><br><span class="line">	if(msgid&#x3D;&#x3D;-1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;creat error\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	msgbuf.mtype&#x3D;getpid();&#x2F;&#x2F;发送消息类型</span><br><span class="line">	strcpy(msgbuf.data,&quot;test haha&quot;);</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;发送数据</span><br><span class="line">	&#x2F;&#x2F;int msgsnd(int msqid,struct msgbuf* msgp,int msgsz,int msgflg)</span><br><span class="line">	&#x2F;&#x2F;将msgbuf.data中的数据发送到消息队列中</span><br><span class="line">	ret&#x3D;msgsnd(msgid,&amp;msgbuf,sizeof(msgbuf.data),IPC_NOWAIT);</span><br><span class="line">	</span><br><span class="line">	if(ret&#x3D;&#x3D;-1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;send message error\n&quot;);</span><br><span class="line">		return -1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	memset(&amp;msgbuf,0,sizeof(msgbuf));&#x2F;&#x2F;将msgbuf全部格式化为0</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;接收数据</span><br><span class="line">	&#x2F;*</span><br><span class="line">	int msgrcv(int msqid,struct msgbuf* msgp,int msgsz,long msgtyp,int msgflg)</span><br><span class="line">	功能：从msqid代表的消息队列中读取一个msgtyp类型的消息，并吧消息存储在msgp指向msgbuf结构中。</span><br><span class="line">	在成功读取一条消息后，队列中的这条消息将被删除</span><br><span class="line">	*&#x2F;</span><br><span class="line">	ret&#x3D;msgrcv(msgid,&amp;msgbuf,sizeof(msgbuf.data),getpid(),IPC_NOWAIT);</span><br><span class="line">	if(ret &#x3D;&#x3D; -1)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;recv message err\n&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	printf(&quot;recv msg &#x3D; [%s]\n&quot;,msgbuf.data);</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：<br><a href="http://img.blog.csdn.net/20171112201114459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGlhbmdfUXVhbl9IdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" target="_blank" rel="noopener" data-fancybox="group" data-caption class="fancybox"><img alt data-src="http://img.blog.csdn.net/20171112201114459?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvTGlhbmdfUXVhbl9IdWFu/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" title></a></p>
<p><strong>五、信号量</strong><br>信号量（信号灯）：与其他进程间通信方式不大相同，主要用途是保护临界资源。进程可以根据他判定是否能够方位某些共享资源，除了用于访问控制外，还可以用于进程同步。</p>
<p>二值信号量：信号灯的值只能去0或1。最多一个进程访问<br>计数信号量：信号灯的值可以去任意非负值。课多个进程同时访问</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;sys&#x2F;type.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;ipc.h&gt;</span><br><span class="line">#include &lt;sys&#x2F;sem.h&gt;</span><br><span class="line">	int semget(key_t key,int nsems,int semflg);</span><br></pre></td></tr></table></figure></div>

<p>key:键值，由ftok获得<br>nsems：指定打开或者新创建的 信号灯集 中将包含信号灯的数目<br>semflg: 标识，同消息队列</p>
<p>标志位：<br>IPC_CREAT:创建新的消息队列<br>IPC_EXCL：与IPC_CREAT一同使用，表示如果要创建的消息队列已经存在，则返回错误<br>IPC_NOWAIT：读写消息队列要求无法的到满足时，不阻塞</p>
<p>int semop(int semid,struct sembuf *sops,unsigned nsops)<br>功能：对信号量进行控制<br>semid：信号量集的ID<br>sops：是一个操作数组，表明要进行什么操作<br>nsops：sops所指向数组的元素个数</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct sembuf</span><br><span class="line">&#123;</span><br><span class="line">unsigned short sem_num;</span><br><span class="line">short sem_op;</span><br><span class="line">short sem_flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>sem_flg:信号操作标志，可能的选择有两种：<br>IPC_NOWAIT：对信号的操作不能满足时，semop()不会阻塞，并立即返回，同时设定错误信息。<br>IPC_UNDO：程序结束时（不论正常或不正常）释放信号量，这样做的目的在于避免程序在宜昌情况下结束时未将锁定的资源解锁，造成该资源永远锁定。</p>
</div></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Linux%E5%BA%94%E7%94%A8%E7%BC%96%E7%A8%8B/">Linux应用编程    </a></div><div class="post_share"></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2018/07/16/%E8%AE%B02018%E6%9A%91%E6%9C%9F%E5%A4%8F%E4%BB%A4%E8%90%A5%E2%80%94%E2%80%94%E4%B8%9C%E5%8D%8E%E5%A4%A7%E5%AD%A6&amp;%E9%87%8D%E5%BA%86%E5%A4%A7%E5%AD%A6/"><img class="prev_cover lazyload" data-src="/img/随笔/夏令营/cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>记2018暑期夏令营——东华大学&amp;重庆大学</span></div></a></div><div class="next-post pull_right"><a href="/2017/10/31/%EF%BC%88%E4%B8%89%EF%BC%89Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"><img class="next_cover lazyload" data-src="/img/Linux应用编程/cover.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>（三）Linux进程控制</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2017/10/24/（一）Linux文件编程/" title="（一）Linux文件编程"><img class="relatedPosts_cover lazyload"data-src="/img/Linux应用编程/cover.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-20</div><div class="relatedPosts_title">（一）Linux文件编程</div></div></a></div><div class="relatedPosts_item"><a href="/2017/10/31/（三）Linux进程控制/" title="（三）Linux进程控制"><img class="relatedPosts_cover lazyload"data-src="/img/Linux应用编程/cover.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-20</div><div class="relatedPosts_title">（三）Linux进程控制</div></div></a></div><div class="relatedPosts_item"><a href="/2017/10/26/（二）Linux时间编程/" title="（二）Linux时间编程"><img class="relatedPosts_cover lazyload"data-src="/img/Linux应用编程/cover.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2019-12-20</div><div class="relatedPosts_title">（二）Linux时间编程</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 By 特立独型</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="/js/tw_cn.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>